Advance js
------------------------ ------------------------- ---------------------------
** Scope 

1. variable declared with var, let and const keyword outside any block i.e.{} will have a global scope.

2. variable declared inside a block{} with var keyword can be accessed anywhere i.e. global scope
   where as if declared with let or const then it will be of block scope.

3. variable declared inside a function with anytype of keyword can't be accessed outside a
   function.

4. a variable declared inside a funtion1 can be accessed by a funtion2 if declare inside the
   funtion1

------------------------ ------------------------- ---------------------------

** Closure  

if the outer funtion returns the inner function then along with the inner function's definition it will bundle its scope( access of the variables ) for the inner function to use.
inner fn. will have the access to the scope even the outer function has finished its execution.

<><><><>

function outer(){
    let a = 0;

    function inner(){
        a++;
        console.log(a);
    }

    return inner;
}
let fn = outer();
fn();
fn();

<><><><>

----hindi-----> agar koi outer funtion se hum inner function return karwate hai to wo saath me inner function ka scope bi return karega [inner function ka scope matlab vo saare variables jo woh access kar sakta hai ]
this scope chain is called closure in js

------------------------ ------------------------- ---------------------------

** functional currying 

it is the process to bifurgate the function in parts 

function sum(a,b,c){
    return console.log(a+b+c);
}
sum(2,3,5);

not to divide this function in parts we can write the function in the style given below

function curry(fn){
    return function(a){
        return function(b){
            return function(c){
                console.log(a+b+c);
            }
        }
    }
}
const sum = curry();
sum(2)(2)(2);

------------------------ ------------------------- ---------------------------

** this Keyword 

the javascript this keyword which is used in a function refers to the object it belongs to
it makes function reusable by letting you decide the object value
this value is determined entirely on how a function is called/invoked

now there are four ways to invoke a functino and determine the value of this keyword 
 
 1. implicit binding -> if the function is invoked to by the dot notation. this keyword refers to the object in the left
 of the dot

<><><><>

 const person = {
    name: "carbon",
    say_my_name: function(){
        console.log(`my name is ${this.name}`)
    }
 } 
 person.say_my_name();

<><><><>

 here say_my_name is invoke with a dot notation and the object to the left of the dot is person so this will point towards person object

----

2. explicit binding
<><><><>
const person = {
    name: "carbon",
    
 } 
 function say_my_name (){
    console.log(`my name is ${this.name}`)
}
 
say_my_name.call(person);
<><><><>
when a function is defined outside an object and ivoked if we use the  inbuilt javascript call function and mention the object this keyword will point towards that object

----

3. New binding

in javascript we can invoke a functino with new keyword and in such a scenario this keyword will point towards an empty object. this empty object is automatically generated by javascript at time of defining the function

<><><><>

function person(name){
    //this = {}
    this.name = name;
}
const p1 = new person("carbon");
const p2 = new person("silicon");

console.log(p1.name);
console.log(p2.name);

<><><><>
----

4. Default Binding 
  if a function is invoked without a dot notation or call method as in explicit binding then this keyword will point towards the global object and look for the required key 
<><><><>

 // globalThis.name = "carbon";
const person = {
    name : "carbon"
  }

  function say_my_name(){
    console.log(`my name is ${this.name}`);
  }
 
  say_my_name();

  //now to run this code succesfully uncomment the first line of the code 

<><><><>

----
when multiple rules applies order of preference will be 
  new binding > Explicit binding > implicit binding > default binding 

------------------------ ------------------------- ---------------------------

Prototype 

in js every function has this property called Prototype which points towards an object 
we can make use of this Prototype object to determine all our shareable properties.
one use of prototype is to share properties and methods across instances
other use which is pretty significant is inheritance
in js inheritance is supported through the concept of prototype and is refered as prototypal inheritance
<><><><>

// function person(fName,lName){
//     this.firstName = fName;
//     this.lastName = lName;
// }

// const person1 = new person("bruce","wayen");
// const person2 = new person("clark","kent");

// person1.getFullName = function()  {
//   return this.firstName+' '+this.lastName;
// }

// console.log(person1.getFullName());

// we can't use console.log(person2.getFullName) for doin so we have to use the concept of prototype

function person(fName,lName){
    this.firstName = fName;
    this.lastName = lName;
}

const person1 = new person("bruce","wayen");
const person2 = new person("clark","kent");

person.prototype.getFullName = function()  {
  return this.firstName+' '+this.lastName;
}

console.log(person1.getFullName());
console.log(person2.getFullName());


the `prototype` object is a property of a constructor function in JavaScript. When an object is created using the `new` keyword and a constructor function, the object's internal `[[Prototype]]` property is set to the `prototype` object of the constructor function. This allows the object to inherit properties and methods from the `prototype` object.

------------------------ ------------------------- ---------------------------

Prototype Chaining

when we inherit one prototype object of a cunstructor function to another cunstructor function 

function Animal(name) {
  this.name = name;
}

Animal.prototype.sayName = function() {
  console.log(`My name is ${this.name}`);
};

function Dog(name, breed) {
  //this = {}
  Animal.call(this, name); // Call Animal constructor with `this` context ** this keyword in constructor function Animal
                          //will now refer to this = { } in Dog function 
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype); // Set Dog prototype to inherit from Animal prototype

Dog.prototype.constructor = Dog; // Set constructor of Dog.prototype to Dog  ??????????????????????????

Dog.prototype.bark = function() {
  console.log('Woof!');
};

const myDog = new Dog('Buddy', 'Golden Retriever');
myDog.sayName(); // Logs 'My name is Buddy'
myDog.bark(); // Logs 'Woof!'

